# Occamy 协议手册

本文提供了 Occamy 协议的全部细节。

[TOC]

## 综述

### 设计

Occamy 协议被设计为通用的远程桌面通信协议。每一条操作指令由以下格式表示：

```
OPCODE,ARG1[,ARG2,...];
```

每个元素包含一个由小数分割的整数前缀以及一个元素值的后缀。前缀表示了后缀字符的长度
（用于处理 UTF-8 编码的 Unicode 字符），即：

```
LENGTH.VALUE
```

例如：

```
4.size,1.0,4.1024,3.768;
```

表示长度为 4 的 size 指令，接受参数 layer, width, height 对应值分别
为 0, 1024, 768。

### 连接

#### 建立连接

客户端与服务端间通过 WebSocket 与 JWT 认证的方式建立连接。在申请 JWT Token 时，
需要向服务端提交需要连接的远程桌面服务器信息：

```
{
      protocol: "vnc",
      host: "172.16.238.11:5901",
      username: "",
      password: "vncpassword"
}
```

即可建立连接。

#### 连接管理

当客户端或服务端出现变化时（例如，键盘被按下、鼠标移动或者剪贴板数据修改），都会被描述为 Event 被发送。最后，服务端和客户端之间可以随时结束连接。服务器或客户端可以无条件使用 `disconnect` 或 `error` 指令来关闭连接。

#### 连接通信

Occamy 应用通常以客户端控制远程桌面服务器为场景。因此，连接握手完成后，客户端主要向服务端发送控制指令，而服务端则处理指令并向客户端发送绘制指令。时序图如下：

```
       Client                           Server
         |                                 |
         |      Control Instructions       |
         |-------------------------------->|
         |    Render Instructions; sync;   |
         |<--------------------------------|
         |               sync;             |
         |-------------------------------->|
         |                                 |
         |                                 |
         |               nop;              |
         |<--------------------------------|
         |               nop;              |
         |-------------------------------->|
         |                                 |
         |            disconnect;          |
         |-------------------------------->|
         |              error;             |
         |<--------------------------------|
         |                                 |
         |                                 |
```

### 数据封装

#### 图像合成

Occamy 协议通过 Channel Mask 提供合成操作。Channel Mask 这个术语简化了设计协议时的一种描述机制，这个机制整合了四种不同图像数据源的所有合成操作，这些数据源包括：不透明的源图像、透明的源图像、不透明的目标图像以及透明的目标图像。通过给这些 channel 分配一个二进制值，为每个可能的合成操作创建了一个唯一的整数 ID，而这些操作并联了 [Porter 和 Duff 论文中描述的操作](https://keithp.com/~keithp/porterduff/p253-porter.pdf)。由于 HTML5 canvas 标签同样适用了 Porter/Duff 来描述合成操作，支持 Occamy 协议与 Web 浏览器中已经存在的合成操作非常相似，某些操作则还没有支持。目前所有浏览器可以支持：

| 操作名称 | 操作码（十六进制） | 操作码（二进制） | 操作说明                                                     |
| -------- | ------------------ | ---------------- | ------------------------------------------------------------ |
| B out A  | 0x02               | 0b0010           | 当源图像不透明时，清除目标图像，否则不做任何操作。对于 mask 很有用。 |
| A atop B | 0x06               | 0b0110           | 仅当目标图像不透明时，使用源图像进行填充                     |
| A xor B  | 0x0A               | 0b1010           | 逻辑亦或。注意，这是一个合成操作，而非逐位运算。当目标图像透明时，绘制源图像；而当源图像透明时，绘制目标图像 |
| A over B | 0x0E               | 0b1110           | 最常见且频繁的合成操作，在所有区域绘制源图像，但是在源图像透明的区域里保留目标图像。 |
| A + B    | 0x0F               | 0b1111           | 简单的将源图像的部件加到目标图像上，超过的部分直接设置为纯白色 |

而这些操作已经实现，但可能在基于 WebKit 的总是在源图像透明时包含目标图像的浏览器上不能正常工作：

| 操作名称 | 操作码（十六进制） | 操作码（二进制） | 操作说明                                                     |
| -------- | ------------------ | ---------------- | ------------------------------------------------------------ |
| B in A   | 0x01               | 0b0001           | 仅当源图像不透明时，绘制目标图像；清除所有源图像或目标图像透明的区域 |
| A in B   | 0x04               | 0b0100           | 仅当目标图像不透明时，绘制源图像；清除所有源图像或目标图像透明的区域 |
| A out B  | 0x08               | 0b1000           | 仅当目标图像透明时，绘制源图像；清除源图像或目标图像不透明的区域 |
| B atop A | 0x09               | 0b1001           | 仅当源图像不透明时使用目标图像进行填充                       |
| A        | 0x0C               | 0b1100           | 无视目标图像直接填充源图像                                   |

而这些操作已经定义，但尚未实现，因为 HTML5 canvas 中不存在此操作：

| 操作名称       | 操作码（十六进制） | 操作码（二进制） | 操作说明                                                     |
| -------------- | ------------------ | ---------------- | ------------------------------------------------------------ |
| Clear          | 0x00               | 0b0000           | 清空目标图像中已存在的图像数据                               |
| B              | 0x03               | 0b0011           | 什么也不做                                                   |
| A xnor B       | 0x05               | 0b0101           | 当目标图像或源图像不透明时，将源图像添加到目标图像；而当目标或源图像透明时清空所有内容。除了与 A+B 在透明时具有可加性不同之外，其他类似 |
| (A + B) atop B | 0x07               | 0b0111           | 当目标不透明时，将源图像添加到目标图像，否则保留目标图像     |
| (A + B) atop A | 0x0D               | 0b1101           | 当源图像不透明时，将目标图像添加到源图像，否则复制源图像     |

Occamy 协议与其他远程桌面协议一样，提供了发送任意矩形图像数据以及将他们防止在一个缓存或显示在屏幕上的方法。Occamy 协议的原始图像数据通过 `img` 指令，并以 PNG, JPEG 或者 WebP 格式的数据进行流式传输。根据使用的格式不同，发送的图像可能是 RGB 或 RGBA，并且可以被 libguac 自动调色。图像数据和其他音频、文件等数据一样，会被 Occamy 的流式系统进行广义化传输。

图像数据可以从一层或缓冲区复制到另一层或另一个缓冲区。这种操作用于滚动更新（更新的图像大部分内容与先前状态相同）或缓存部分图像。VNC 和 RDP 均提供了拷贝屏幕数据的一个区域并将其放置在相同屏幕内的灵异区域的方法。RDP 则提供了另一种手段，可以将数据复制到缓存、或从该缓存中调用数据并将其放在屏幕上。Occamy 则进一步简化了这种概念，因为屏幕上和屏幕外的图像存储都是相同的。Occamy 使用 `copy` 指令来复制矩形图像数据，并将其放在另一层中，无论该层是否与源图层、不同的可见层还是屏幕外的缓存相同。

Occamy 协议提供了类似于 HTML5 canvas 的基本图像操作。大部分情况下，这些原语对于远程绘制、发送相应的 PNG 图像使用更少的带宽是相当有帮助的。注意，过度使用这些原语会降低客户端的性能，尤其是当客户端位于性能较低的机器上时。

#### 图层与缓存

Occamy 协议中的所有绘制操作都会影响一个图层，每个图层会有一个整数索引来进行标识。当这个标识为负时，标识图层不可见，可以作为图像数据的缓存。这种情况下，该层会在代码中被引用，且在首次引用图层时就会自动创建图层。

同时，总是有一个主图层（默认图层）的索引为 0。调整该层大小意味着调整了整个远程图像。其他图层则会在创建时遵循默认图层的大小，缓存始终以 0x0 的大小进行创建，并自动调整其大小以适应其内容。

非缓存层可以被移动并嵌套到其他层中。这种情况下，图像会提供简单的硬件加速合成方法。如果你需要一个窗口显示在其他之上，亦或有一些需要移动的对象并需要将其数据保留，则图层是实现此目的的最好方式。如果图层嵌套在另一个图层中，则其位置对于父图层来说是相对的。当父图层被移动或者重新移动时，子图层同样会被移动。如果子图层扩展并超出父图层的边界，则图像会被裁剪。

#### 流式对象

Occamy 支持传输剪贴板内容、音频、视频、图像数据、文件以及任意命名的管道。流是由指令分配、并关联了特殊语义和元数据。例如，`audio` 或 `video` 指令用于播放媒体、`file` 指令用于文件传输，而 `pipe` 指令用于传输客户端与服务端之间的任意数据。某些情况下，我们可以使用「对象」这一名词来对流的结构化集合指定其可用性及语义。

一旦分配了流，就可以使用 `blob` 指令以块的形式沿着流发送数据，并可以有接收端通过 `ack` 指令进行确认，最后使用 `end` 指令来表示流的终止。

### `occamyd` 代理进程

`occamyd` 是 Occamy 服务端的守护进程，其在内部使用 goroutine 的方式（而非进程或线程）维护了所有的用户连接。每当一个新的用户尝试建立长连接时，会启动一个单独的 goroutine 来进行数据的代理通信。

### `occamy-lib` 与协议客户端插件

Occamy 守护进程 `occamyd` 通过加载插件的方式来扩展自身功能，也就是源码中的 `lib`。

桌面协议客户端插件通过动态库的方式进行加载，库的名称约定为 `libguac-client-protocol_name`，准守此名字的客户端才会被 `occamyd` 加载。当插件被加载后，`occamyd` 会根据自身客户端的协议握手来调用 `guac_client_plugin_open()` 方法，如果执行成功，则会返回一个 handler 提供给 `occamyd` 使用，并在结束时调用 `guac_client_plugin_close()` 进行回收。当插件成功加载后，occamyd 会调用 `guac_client_plugin_init_client()` 来初始化客户端，该方法会调用客户端内部的 `guac_client_init()`。因此每个客户端插件都必须实现该接口。

当 `occamyd` 按照 Occamy 协议进行握手时，会读取位于静态存储区的以 NULL 为阶段标志的参数名的集合，该变量在客户端插件里声明为 `GUAC_CLIENT_ARGS`，因此客户端插件也必须定义此变量。

握手过程结束后，`occamyd` 会初始化并填充 `guac_client` 数据结构，该结构包含 `guac_client_info` 结构，以及当前连接的客户端收到的参数数量、及参数值一起传递给 `guac_client_init()`。初始化完成后，`occamyd` 会调用 `guac_client` 结构中提供的处理函数来接受并处理任意指令。

----

## 绘制指令

### cfill

将当前 path 填充为指定颜色。该指令结束当前的 path。未来的 path 操作将创建一个新的 path

| 参数  | 说明                                          |
| ----- | --------------------------------------------- |
| mask  | 填充指定图层中当前路径时应用的 channel mask。 |
| layer | 应填充 path 所在的图层。                      |
| r     | 用于填充指定图层中当前路径的颜色的红色分量。  |
| g     | 用于填充指定图层中当前路径的颜色的绿色分量。  |
| b     | 用于填充指定图层中当前路径的颜色的蓝色分量。  |
| a     | 用于填充指定图层中当前路径的颜色的透明分量。  |

### clip

将当前路径应用为 clip path。未来的操作只会在当前路径中进行。请注意，未来的 clip 指令也将受此 path 的限制。要设置全新的 clip path，必须先使用 reset 指令重置图层。如果你只希望重置 clip path，但保留当前变换矩阵，请在设置 clip path 之前 push 图层状态，然后 pop 图层状态以进行 reset 操作。

| 参数  | 说明                   |
| ----- | ---------------------- |
| layer | 应设置剪切路径的图层。 |

### copy

指定图层或缓冲区的指定矩形中的图像数据复制到另一个指定图层或缓冲区的不同位置。

| 参数      | 说明                                         |
| --------- | -------------------------------------------- |
| srclayer  | 要复制图像数据的图层的索引。                 |
| srcx      | 源图层中源矩形左上角的 X 坐标。              |
| srcy      | 源图层中源矩形左上角的 Y 坐标。              |
| srcwidth  | 源图层中源矩形的宽度。                       |
| srcheight | 源图层中源矩形的高度。                       |
| mask      | 在目标图层上绘制图像数据时要应用的通道蒙版。 |
| dstlayer  | 要将图像数据绘制到的图层的索引。             |
| dstx      | 目标图层中目标左上角的 X 坐标。              |
| dsty      | 目标图层中目标左上角的 Y 坐标。              |

### cursor

将客户端的鼠标指针设置为特定区域特定图层的图像数据。

| 参数      | 说明                          |
| --------- | ----------------------------- |
| x         | 鼠标区域的 X 坐标             |
| y         | 鼠标区域的 Y 坐标             |
| srclayer  | 要复制图像数据的图层的索引    |
| srcx      | 源图层中源矩形左上角的 X 坐标 |
| srcy      | 源图层中源矩形左上角的 Y 坐标 |
| srcwidth  | 源图层中源矩形的宽度          |
| srcheight | 源图层中源矩形的高度          |

### dispose

移除指定的图层。如果指定图层再次被引用则会重新创建

| 参数  | 说明             |
| ----- | ---------------- |
| layer | 需要被移除的图层 |

### move

将给定图层移动到指定父图层中的给定位置。此操作仅适用于图层，不能应用于缓冲区（具有负索引的图层）。将此操作应用于默认图层（图层 0）也无效。

| 参数   | 说明                                                  |
| ------ | ----------------------------------------------------- |
| layer  | 需要移动的图层                                        |
| parent | 给定图层的父图层                                      |
| x      | 图层所要移动到的 X 坐标                               |
| y      | 图层所要移动到的 Y 坐标                               |
| z      | 图层的 Z 轴坐标。值较大的图层会出现在值较小图层的上方 |

### rect

添加指定图层的矩形路径。

| 参数   | 说明                              |
| ------ | --------------------------------- |
| mask   | 绘制图像数据时应用的 channel mask |
| layer  | 目标图层                          |
| x      | 要绘制的矩形左上角的 X 坐标       |
| y      | 要绘制的矩形左上角的 Y 坐标       |
| width  | 需要绘制的矩形宽度                |
| height | 需要绘制的矩形高度                |

### shade

设置给定图层的不透明度。

| 参数    | 说明                                                      |
| ------- | --------------------------------------------------------- |
| layer   | 应设置不透明度的图层                                      |
| opacity | 图层的不透明度，其中 0 表示完全透明，255 表示完全不透明。 |

### size

设置指定图层的大小。

| 参数   | 说明               |
| ------ | ------------------ |
| layer  | 需要调整大小的图层 |
| width  | 图层的新宽度       |
| height | 图层的新高度       |

### transfer

使用指定的传递函数将指定图层或缓冲区的指定矩形中的图像数据传输到另一个指定图层或缓冲区的不同位置。

有关可用函数的列表，请参阅 libguac 附带的[`occamy/lib/protocol.go`](https://github.com/changkun/occamy/blob/master/lib/protocol.go)头文件中 `TransferFunc` 的定义。

| 参数      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| srclayer  | 源图层索引                                                   |
| srcx      | 源图层 X 轴坐标                                              |
| srcy      | 源图层 Y 轴坐标                                              |
| srcwidth  | 源图层宽度                                                   |
| srcheight | 源图层高度                                                   |
| function  | 变换函数的索引，具体的函数由 `TransferFunc` 定义。请参考 libguac 头文件 [`occamy/lib/protocol.go`](https://github.com/changkun/occamy/blob/master/lib/protocol.go) |
| dstlayer  | 目标图层索引                                                 |
| dstx      | 目标图层 X 轴坐标                                            |
| dsty      | 目标图层 Y 轴坐标                                            |

## 流媒体指令

### ack

`ack` 指令确认一个收到的数据 blob，提供了一个状态代码和消息来表示与 blob 相关的操作是否成功。除了 `SUCCESS` 之外的状态码隐含了流结束。


| 参数    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| stream  | 收到的 blob 对应的流的索引                                   |
| message | 人类可读的错误消息。它没有在任何用户界面中暴露，仅用于调试目的。 |
| status  | 表示成功或失败的 Occamy 状态码。                          |

### audio

分配一个新流，并将其关联到给定的音频元数据上。音频数据会随后被 blob 指令沿流进行发送。mimetype 必须在之前的客户端握手阶段中指定。一旦从流中收到 blob 指令则会立即开始并持续播放。

| 参数     | 说明                      |
| -------- | ------------------------- |
| stream   | 需要分配的流的索引        |
| mimetype | 发送流音频数据的 mimetype |

### blob

沿给定流发送一个二进制大对象的数据。数据的 blob 可以是任意的，经过 base64 编码后的，仅在 Guacsmole 客户端或服务端之间有意义的分配给指定流的数据。

| 参数   | 说明                          |
| ------ | ----------------------------- |
| stream | 给定数据所关联的流的索引      |
| data   | base64 编码后的需要发送的数据 |

### clipboard

分配新流，并关联到给定的剪贴板元数据上。剪贴板数据随后会沿流通过 blob 指令进行发送。如果通过客户端进行发送，则数据为客户端剪贴板。如果由服务端发送，则数据为远程桌面的剪贴板。

| 参数     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| stream   | 要分配的流的索引                                             |
| mimetype | 要发送的剪贴板数据的 minetype。大部分情况下为 `text/plain`。 |

### end

 `end` 指令停止一个开放的流，并释放任何客户端或服务器端资源。向已终止流发送数据将被忽略。使用 `end` 指令终止流仅表示流的结束，并不表示错误。

| 参数   | 说明                         |
| ------ | ---------------------------- |
| stream | 收到的对应的 blob 的流的索引 |

### file

分配新流，并将其关联到给定的任意文件的元数据上。文件的内容会随后被 `blob` 指令沿流进行发送。文件的完整大小不需要提前知晓。

| 参数     | 说明                                   |
| -------- | -------------------------------------- |
| stream   | 要分配的流的索引                       |
| mimetype | 发送文件的 minetype                    |
| filename | 发送文件的名字，可以被 filesystem 保存 |

### img

分配新流，将其与图像更新的元数据相关联，包括图像类型，目标图层和目标坐标。 稍后将使用 `blob` 指令沿着流发送图像的内容。 无需提前知道图像的完整尺寸。

| 参数     | 说明                                |
| -------- | ----------------------------------- |
| stream   | 要分配的流的索引                    |
| minetype | 正在发送的图像的 mimetype。         |
| mask     | 绘制图像数据时应用的 channel mask。 |
| layer    | 目标图层。                          |
| x        | 目标图层中目标左上角的 X 轴坐标。   |
| y        | 目标图层中目标左上角的 Y 轴坐标。   |

### nest

在单个指令内编码一个或多个指令的一部分，并将该数据包与流的索引相关联。 具有相同流索引的未来嵌套指令将其数据附加到客户端上的相同逻辑流。一旦在客户端接收到嵌套后的数据，客户端就会按顺序立即执行相关流中的任何已完成的指令。

| 参数  | 说明                                                         |
| ----- | ------------------------------------------------------------ |
| index | 数据应附加到的流的索引。此索引可以是任意的，并且仅表示应如何重新组装嵌套数据。 |
| data  | 协议数据，包含一个或多个指令的一部分。                       |

### pipe

分配一个新流，将其与给定的任意命名管道元数据相关联。随后将使用 `blob` 指令沿着流发送管道的内容。 Occamy 协议中的管道是单向的命名管道，非常类似于 UNIX FIFO 或管道。由客户端代码来适当地处理管道数据，可以是基于管道的任何名称。管道可以由客户端或服务器打开。

| 参数     | 说明                                           |
| -------- | ---------------------------------------------- |
| stream   | 要分配的流的索引                               |
| minetype | 沿管道发送的数据的 mimetype。                  |
| name     | 管道的任意名称，可能对客户端代码具有特殊含义。 |

### video

分配一个新流，将其与给定的视频元数据相关联。随后将使用 `blob` 指令沿流发送视频数据。给定的 mimetype 必须是在握手过程中客户端先前指定的 mimetype。只要在流中收到 blob，播放就会立即开始并继续播放。

| 参数     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| stream   | 要分配的流的索引                                             |
| layer    | 视频流将要传入的图层索引。播放过程中的对该层的其他绘制操作是未定义的。因为客户端中包括硬解码在内的任何编解码器可以实现为任何合适的任何渲染机制。 |
| mimetype | 正在发送的视频数据的 mimetype。                              |

## 对象指令

### filesystem

分配一个新的对象，并将其与给定的任意 filesystem 元数据进行关联。filesystem 内的文件的内容及目录会沿流进行发送并使用 `get` 指令请求或者 `put` 指令创建。

| 参数   | 说明               |
| ------ | ------------------ |
| object | 要分配的对象的索引 |
| name   | filesystem 的名称  |

### get

创建一个新的流的请求，提供了给定名字的对象流的读访问。请求的流会被创建，并通过 body 指令进行返回。

除了对象本身的具有保留名称 `/` 的根流之外，流的名字可以是任意的并由对象的请求来指定。对象的根流具有 `application/vnd.glyptodon.guacamole.stream-index+json` 的 minetype，并提供了关于有效的流名称与他们对应的 minetype 之间映射的 JSON 对象。如果一个对象包含了流的层次结构，那么这些流中的某些可以是 `application.glyptodon.guacamole.stream-index+json`。

例如，对包含两个文本流 A 和 B 对象的根流的 get 请求的响应的最终内容如下：

```
{
    "A" : "text/plain",
    "B" : "text/plain"
}
```

| 参数   | 说明                   |
| ------ | ---------------------- |
| object | 要请求流的对象的索引   |
| name   | 给定对象请求的流的名字 |

### body

分配一个新的流，并将其关联到先前的 get 指令指定的名字。流的内容会随后被 blob 指令发送。流的大小不需要提前知道。

| 参数     | 说明                  |
| -------- | --------------------- |
| object   | 与流关联的对象的索引  |
| stream   | 要分配的流的索引      |
| minetype | 被发送数据的 minetype |
| name     | 与对象关联的流的名字  |

### put

分配一个新的流，并将其与跟定的任意对象和流的名称进行关联。流的内容随后会被 blob 指令发送。

| 参数     | 说明                               |
| -------- | ---------------------------------- |
| object   | 与流关联的对象的索引               |
| stream   | 要分配的流的索引                   |
| minetype | 要发送数据的 minetype              |
| name     | 给定对象中要向其发送数据的流的名称 |

## 客户端握手指令

### size

指定客户端最优屏幕尺寸与分辨率。该指令为握手阶段的发送的第二个指令。

| 参数   | 说明                     |
| ------ | ------------------------ |
| width  | 最优屏幕宽度             |
| height | 最优屏幕高度             |
| dpi    | 最优屏幕分辨率，近似 DPI |

### audio

指定客户端所支持音频的 minetypes 。每个参数必须是单一的 minetype，按客户端的偏好进行排序，最优的 minetype 为第一个参数。该参数为协议握手阶段发送的第三个指令。

### image

指定客户端支持的图像 minetype。每个参数必须是一个单一的 minetype，按客户端的偏好顺序进行排序，最优的 minetype 为第一个参数。该参数为协议握手阶段发送的第五个指令。

支持的 minetype 期望至少包含 image/png 和 image/jpeg，并且握手阶段没有发送这些参数，服务端也支持这些类型。

## 客户端控制指令

### disconnect

通知服务端关闭连接。此指令可以在任何阶段发送，没有参数。

### nop

客户端 `nop` 指令什么也不做，也没有参数，并总是被服务器忽略。主要作为保持连接的信号，并可以在连接不活跃时候由 Occamy 客户端发送来判断连接是否已被关闭或者超时。

### sync

用于报告所有由服务器提供的时间戳之前的操作均已被执行。如果客户端收到一个来自服务端的 `sync` ，则客户端必须执行完时间戳之前的所有操作并回复一个对应的 `sync`，否则服务端会在客户端赶上操作前停止发送新的内容。对于客户端而言，发送一个领先服务端时间戳的 `sync` 指令会导致一个错误。

| 参数      | 说明                   |
| --------- | ---------------------- |
| timestamp | 一个有效的服务端时间戳 |

## 服务端控制指令

### disconnect

通知客户端连接已被服务端关闭。此消息可以在任何阶段被服务器发送，且无任何参数。

### error

| 参数   | 说明                        |
| ------ | --------------------------- |
| text   | 描述错误的任意消息          |
| status | 描述错误的 Occamy 状态码 |

### mouse

报告用户当前连接已经将鼠标移动到给定的位置。

| 参数 | 说明                |
| ---- | ------------------- |
| x    | 鼠标指针的 x 轴坐标 |
| y    | 鼠标指针的 y 轴坐标 |

### nop

`nop `指令什么也做，也没有任何参数，并全局被 Occamy 客户端忽略。它主要用于保持连接，它可以在没有任何活跃的阶段来由 guacd 或客户端插件来进行发送进而确认连接是否被发送或已被关闭。

### sync

用于指示所有先前操作的当前时间戳。客户端必须响应每个收到的 `sync` 指令。客户端和服务端彼此偶尔会发送 `sync` 并报告当前操作的状态。

| 参数      | 说明                   |
| --------- | ---------------------- |
| timestamp | 一个有效的服务端时间戳 |

## 客户端事件

### mouse

发送指定鼠标的移动、按钮是否被按压（或其组合）的事件

| 参数 | 说明                                          |
| ---- | --------------------------------------------- |
| x    | 鼠标指针的 x 轴坐标                           |
| y    | 鼠标指针的 y 轴坐标                           |
| mask | 按钮的 mask，表示每个鼠标按键的按下与释放状态 |

### size

指定客户端的握手过程中、或者前一个发送的 `size` 指令变化后的最佳屏幕尺寸

| 参数   | 说明             |
| ------ | ---------------- |
| width  | 新的最佳屏幕宽度 |
| height | 新的最佳屏幕高度 |

## 错误状态码

某些 Occamy 指令和 Occamy 内部使用相同的错误代码。这些代码表示了操作的成功或失败，可以在用户界面中以人类可读的方式进行渲染。

| 代码 | 名称                 | 描述                                                         |
| ---- | -------------------- | ------------------------------------------------------------ |
| 0    | SUCCESS              | 操作成功，无错误。                                           |
| 256  | UNSUPPORTED          | 请求操作尚未支持                                             |
| 512  | SERVER_ERROR         | 内部错误，操作无法执行                                       |
| 513  | SERVER_BUSY          | 服务器繁忙，操作无法执行                                     |
| 514  | UPSTREAM_TIMEOUT     | 上游服务器无响应。大部分情况下，上游服务器是远程桌面服务器   |
| 515  | UPSTREAM_ERROR       | 上游服务器错误。大部分情况下，上游服务器是远程桌面服务器     |
| 516  | RESOURCE_NOT_FOUND   | 关联的文件、或流资源未找到，操作失败                         |
| 517  | RESOURCE_CONFLICT    | 资源正在本使用或被锁住，操作请求被阻止                       |
| 518  | RESOURCE_CLOSED      | 关联的资源已经被关闭，操作无法继续                           |
| 519  | UPSTREAM_NOT_FOUND   | 上游服务器未找到，或在网络中丢失。大部分情况下，上游服务器是远程桌面服务器 |
| 520  | UPSTREAM_UNAVALIABLE | 上游服务器拒绝连接服务。大部分情况下，上游服务器是远程桌面服务器 |
| 521  | SESSION_CONFLICT     | 上游服务器会话因与其他会话冲突而被中断。大部分情况下，上游服务器是远程桌面服务器 |
| 522  | SESSION_TIMEOUT      | 上游服务器会话不活跃且被中断。大部分情况下，上游服务器是远程桌面服务器 |
| 523  | SESSION_CLOSED       | 上游服务器会话被强制中断，大部分情况下，上游服务器是远程桌面服务器 |
| 768  | CLIENT_BAD_REQUEST   | 请求参数非法或无效                                           |
| 769  | CLIENT_UNAUTHORIZED  | 因用户未登陆产生的无权限。注意，用户可能已登陆到 Occamy，但没有登陆到对应的远程桌面服务器 |
| 771  | CLIENT_FORBIDDEN     | 缺少权限，登陆无法解决此问题                                 |
| 776  | CLIENT_TIMEOUT       | 客户端超时，通常为用户的 Occamy 或浏览器                  |
| 781  | CLIENT_VOERRUN       | 客户端发送了协议允许的更多数据                               |
| 783  | CLIENT_BAD_TYPE      | 客户端发送的数据包含非法类型                                 |
| 797  | CLIENT_TOO_MANY      | 客户端已使用太多资源。在产生新的请求前，旧资源必须被释放     |

## License

[Occamy](https://github.com/changkun/occamy) | [MIT](./LICENSE) &copy; 2019 [Ou Changkun](https://changkun.de)